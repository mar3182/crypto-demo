{"version":3,"file":"PortfolioNFTService-ClY1-qmH.js","sources":["../../node_modules/ethers/lib.esm/utils/fixednumber.js","../../node_modules/ethers/lib.esm/utils/units.js","../../src/utils/PortfolioNFTService.js"],"sourcesContent":["/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport { getBigInt, getNumber, fromTwos, mask, toBigInt } from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        }\n        else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            assertArgument(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        defineProperties(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        assertArgument(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : getNumber(_decimals);\n        const format = getFormat(_format);\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = fromTwos(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map","/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nimport { assertArgument } from \"./errors.js\";\nimport { FixedNumber } from \"./fixednumber.js\";\nimport { getNumber } from \"./maths.js\";\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nexport function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nexport function parseUnits(value, unit) {\n    assertArgument(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n    return FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nexport function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nexport function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map","import { ethers } from 'ethers';\nimport PortfolioNFTArtifact from '../artifacts/src/contracts/PortfolioNFT.sol/PortfolioNFT.json';\n\n// Contract address from environment variables\nconst CONTRACT_ADDRESS = import.meta.env.REACT_APP_CONTRACT_ADDRESS_ACHIEVEMENT || '0x5FbDB2315678afecb367f032d93F642f64180aa3';\nconst NETWORK_URL = import.meta.env.REACT_APP_NETWORK_URL || 'https://sepolia.infura.io/v3/509fb9fd78ef4236a48802c5f2c78616';\nconst CHAIN_ID = parseInt(import.meta.env.REACT_APP_CHAIN_ID || '11155111');\n\n/**\n * Helper class to interact with the PortfolioNFT smart contract\n */\nexport class PortfolioNFTService {\n  constructor(provider, signer) {\n    // If no provider is supplied, create one using the network URL\n    if (!provider) {\n      provider = new ethers.JsonRpcProvider(NETWORK_URL);\n    }\n    \n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(CONTRACT_ADDRESS, PortfolioNFTArtifact.abi, signer || provider);\n    this.chainId = CHAIN_ID;\n  }\n\n  /**\n   * Get the current mint price\n   * @returns {Promise<string>} The mint price in ETH\n   */\n  async getMintPrice() {\n    const price = await this.contract.mintPrice();\n    return ethers.formatEther(price);\n  }\n\n  /**\n   * Mint a new Portfolio NFT\n   * @param {string} recipient - The address to receive the NFT\n   * @returns {Promise<Object>} The transaction receipt\n   */\n  async mintPortfolioNFT(recipient) {\n    if (!this.signer) throw new Error('Signer required to mint an NFT');\n    \n    const price = await this.contract.mintPrice();\n    const tx = await this.contract.mintPortfolioNFT(recipient, { value: price });\n    const receipt = await tx.wait();\n    \n    return receipt;\n  }\n\n  /**\n   * Create a new challenge\n   * @param {Object} challenge - The challenge details\n   * @returns {Promise<Object>} The transaction receipt\n   */\n  async createChallenge(challenge) {\n    if (!this.signer) throw new Error('Signer required to create a challenge');\n    \n    const tokenId = 1; // Default to token ID 1 for demo purposes\n    \n    const tx = await this.contract.createChallenge(\n      tokenId,\n      challenge.title,\n      challenge.description,\n      challenge.skills,\n      challenge.complexity,\n      challenge.timeframe,\n      challenge.includesRoadmap,\n      challenge.roadmapSteps || [],\n      challenge.compensation\n    );\n    \n    const receipt = await tx.wait();\n    return receipt;\n  }\n  \n  /**\n   * Verify the connected network matches the expected chain ID\n   * @returns {Promise<boolean>} Whether the network is correct\n   */\n  async verifyNetwork() {\n    const network = await this.provider.getNetwork();\n    return network.chainId === BigInt(this.chainId);\n  }\n  \n  /**\n   * Switch to the correct network if using MetaMask\n   * @returns {Promise<boolean>} Whether the switch was successful\n   */\n  async switchNetwork() {\n    if (!window.ethereum) return false;\n    \n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: `0x${this.chainId.toString(16)}` }],\n      });\n      return true;\n    } catch (error) {\n      console.error('Failed to switch network:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new challenge with roadmap steps\n   * @param {Object} challenge - The challenge details\n   * @returns {Promise<Object>} The transaction receipt\n   */\n  async createChallengeWithRoadmap(challenge) {\n    if (!this.signer) throw new Error('Signer required to create a challenge');\n    \n    const tokenId = 1; // Default to token ID 1 for demo purposes\n    \n    const tx = await this.contract.createChallenge(\n      tokenId,\n      challenge.title,\n      challenge.description,\n      challenge.skills,\n      challenge.complexity === 'easy' ? 1 : challenge.complexity === 'medium' ? 2 : 3,\n      challenge.timeframe,\n      challenge.includeRoadmap,\n      challenge.roadmapSteps.map(step => step.description),\n      challenge.compensation || ''\n    );\n    \n    const receipt = await tx.wait();\n    return receipt;\n  }\n\n  /**\n   * Check if an address owns a Portfolio NFT\n   * @param {string} address - The address to check\n   * @returns {Promise<boolean>} True if the address owns an NFT\n   */\n  async isPortfolioNFTOwner(address) {\n    try {\n      const balance = await this.contract.balanceOf(address);\n      return balance > 0;\n    } catch (error) {\n      console.error('Error checking NFT ownership:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get challenges created by a specific NFT owner\n   * @param {string} creator - The address of the challenge creator\n   * @returns {Promise<Array>} Array of challenges\n   */\n  async getChallenges(creator) {\n    const tokenId = 1; // Default to token ID 1 for demo purposes\n    return await this.contract.getChallenges(tokenId, creator);\n  }\n}\n\nexport default PortfolioNFTService;\n"],"names":["BN_N1","BN_0","BN_1","BN_5","_guard","Zeros","getTens","decimals","result","checkValue","val","format","safeOp","width","limit","assert","fromTwos","mask","getFormat","value","signed","match","assertArgument","v","check","key","type","defaultValue","name","toString","negative","str","index","_FixedNumber","guard","__privateAdd","_FixedNumber_instances","__publicField","_format","_val","_tens","assertPrivate","__privateSet","_value","defineProperties","__privateGet","other","__privateMethod","add_fn","sub_fn","mul_fn","checkFormat_fn","checkValue_fn","div_fn","a","b","delta","bump","tens","_decimals","getNumber","getBigInt","whole","decimal","toBigInt","getBytes","o","FixedNumber","formatUnits","unit","formatEther","wei","CONTRACT_ADDRESS","NETWORK_URL","CHAIN_ID","PortfolioNFTService","provider","signer","ethers.JsonRpcProvider","ethers.Contract","PortfolioNFTArtifact","price","ethers.formatEther","recipient","challenge","error","step","address","creator"],"mappings":"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","x_google_ignoreList":[0,1]}